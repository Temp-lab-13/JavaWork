package OOP.Lesson.LessonOne;

public class Point2D {
    // Поля класса (переменные)
    int x, y;

    // Конструктор, позволяющий создать экземпляр классла
    // и сразу же передать в него какие-то значения, использую поля класса.

    public Point2D(int valueX, int valueY) {
        x = valueX;
        y = valueY;
        // переданные при создании экземпляра класса аргументры,
        // присваиваются полям класса. Так мы наполняем аргументы создаваемого класса
        // какими-то значениями.
        // НО! Создавая конструктор,мы переопределяем конструктор по умолчанию,
        // сто делает создание пустого экземпляра класса не возможным.
    }
    // Что бы вернуть эту возможность, создаём ещё один констрктор.
    // Конструктор, позволяющий создать пустой экземпляр класса.
    // Т.е не передавая в него при создании никаких значенийй.

    public Point2D() {
        x = 0;
        y = 0;
    }

    // Так же можно создать большое множество других конструкторов,
    // различающихся колличеством и даже типом передаваемых в него аргументов.
    // Вызываться будет автоматически тот конструктор, который подходит.

    // public Point2D(int a) {
    // x = a;
    // }

    // Так же, можно переиспользовать другие конструкторы, что каждый раз не
    // прописывать один и то же код.
    // Пример ниже, по сути обращается к конструктору с двумя аргументами,
    // воспроизведя его логику, но при этом получая лишь одни аргумент.
    // При этом, не получаемым значениям можно присваивать свои значения.
    public Point2D(int a) {
        this(a, a = 1);
    }

    // Специальный метод выводящий в консоль соержимое полей класса х и y.
    public String getInfo() {
        return String.format("x: %d, y: %d", x, y);
    }

    // типичное переопределние метода. Разумеется, не обязательно создавать
    // отдельный метод,
    // что бы потом вызвать его логику в этом методе, всё можно прописать по метсту.
    // но, важно помнимать, что после этого, метод будет работать только так,
    // как заложено в прописанной в нём логике. Что может вызвать проблемы при
    // попытке,
    // использовать его в иных местах программы по старому.
    /*
     * @Override
     * public String toString(){
     * return getInfo();
     * }
     */

}
