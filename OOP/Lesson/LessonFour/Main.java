package OOP.Lesson.LessonFour;

import java.util.ArrayList;
import java.util.List;

import Lesson.LessonThree.Arrays;

/**
 * Main
 */
public class Main {

    public static void main(String[] args) {

        /*
         * Пример использования "сырых" типов.
         * Мы создаём "лист" без указания типа данных в треугольных скобках.
         * В результате чего, лист будет записывать любые в него данные как Object.
         * Это позволит положить в этот лист и строки и числа и почти что угодно -
         * Все они будут приобразовываться в Object.
         * Но при обработке такой сборной солянки типов в пределах одной коллексции,
         * мы легко можем поймать ошибки, при попытке обработать Object соержащий
         * строку, как число.
         * В итоге, это удобно, когда нужно просто сохнаить какие-то примитивные,
         * разнородные типы данных, с которыми, не кроме как чтения,
         * не будет проводиться никаких манипуляций,
         * или когда мы не знаем что за тип данных вообще будет использоваться, но
         * для него достаточно будет такого же узкого функционала как запись/чтение.
         * Но не более.
         */
        // Создаём лист без указания типа данных.
        List list = new ArrayList();
        // Записываем в лист строки (5 раз).
        for (int i = 1; i <= 5; i++) {
            list.add(String.format("string %d", i));
        }
        // Смотрим что всё работает и строки записаны.
        System.out.println(list);
        // Добавляем сюдаже уже число.
        list.add(123);
        // И видим что они так же легко записались и считываются,
        // не смотря на соседство со строками.
        System.out.println(list);

        /*
         * Более правильная и продвинутая форма работа с неизвестными или разнороднами
         * типами
         * да ещё на пимреме слоных типов, по сути представляющих разные объекты.
         * Представляет из себя обощённое параметизарование. Когда вместо указания
         * конкретного
         * типа, указывается "Общий" параметр, на место которого при работае ставится
         * уже конретный,
         * нужный нам параметр, будь то притивы вроде чисел или строк,
         * или же сложные разнородные объекты.
         */
        // Пример использования Параметризированого объекта.
        // Объект описан в "PerametrzedWorker.java"
        // При создании объекта, мы казываем тип с которым мы работаетм(<Integer>),
        // в данном данном случаи, это Integer, который как бы подставляется вместо E.
        PerametrzedWorker<Integer> worker1 = new PerametrzedWorker<Integer>(
                01,
                "Alen",
                "Dox",
                33,
                22);
        // или же String. Таким образом, мы можем создать объект с любым типам, кторый
        // будет посдтавляться
        // в тело класса, что позволяет не создавать копии класов, заточенные под
        // конкретный тип данных.
        // а так же даёт возмоность исполльзовать этот класс с заранее не
        // предусмотренными типами.
        PerametrzedWorker<String> worker2 = new PerametrzedWorker<String>(
                "01",
                "Alen",
                "Dox",
                33,
                22);
        // Создание класса с многочисленными обощёнными парметрами,
        // по сути так же не отличается от одиночного,
        // Нужно лишь указываться для каждого обощённого параметра нужный тип данных.
        // Разумеется, порядок важен.
        MultiParametzidWorker<Integer, Integer, Integer> worker3 = new MultiParametzidWorker<Integer, Integer, Integer>(
                02,
                "Lonhg",
                "Dater",
                20,
                18);

        /*
         * Пример использования обощённых методов.
         * Суть в том, что бы передать в метод какое-то значение, без привязки к
         * какому-то конкретному типу данных.
         * И при необходимости, вернуть значение в виде полученнного типа данных.
         * Поисание мтода в классе Mathods.java
         */
        // Создаём тестовый лист, с типом данных Integer.
        List<Integer> date = new ArrayList<>();
        // Заполняем числами от 0 до 4х. Всего пять позиций(индексов)
        for (int i = 0; i < 5; i++) {
            date.add(i);
        }
        // Вызываем метод(getElementCillections) из класса Mathods передавая коллеккцию
        // и позицию значение которой мы хотим вернуть,
        // сохранив её в перменную elem, которую просто распечатывам.
        Integer elem = Mathods.getElementCillections(date, 1);
        System.out.println(elem);

    }
}