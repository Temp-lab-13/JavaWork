package OOP.Lesson.LessonFour;

import java.util.List;

public class Mathods {
    // Класс содержит два статичных метода. первый рабочий, второй для примера.

    /*
     * <U> перед названием метода, по сути инициализирует на уровне этого метода
     * обощёный тип данных,
     * который используется в дальнейшем в принмаемой коллекции, и так же
     * указывается как возращаемый тип.
     */

    /*
     * Как это работает:
     * Мы, вызывая метод в Vain из этого класса. Отправляем ему первым аргументом
     * существующую коллекции с определённым
     * при создании типом данных (В нашем примере это коллекция List<Integer>).
     * Integer автоматически подставляется вместо <U> как тип данных, позволяя
     * внутри метода работать с содерижмым коллекции,
     * как с числами.
     * Возращаемый тип U поставленый перед "getElementCillections" так же принимает
     * форму Integer.
     * В итоге, мы полчаем интовую колекцию и по указангому индексу возращаем
     * интовое значение.
     */
    public static <U> U getElementCillections(List<U> collection, int index) {
        return collection.get(index);
    }

    /*
     * В этом примере, таже схема, с той лишь разницей, что используется несколько
     * обощённых типов <T1> и <T2>.
     * Каждый из них так же необходимои "инициализировать" перед названием метода(и
     * указанием возращаемого типа) в
     * <тиаких> скобках, через запятую. Что бы их можно было исользовать в
     * получаемых аргументах,
     * как возращаемый тип(T2 перед put), и в смомо методе (возвращаем arg2 типа
     * T2).
     */
    public static <T1, T2> T2 put(T1 arg1, T2 arg2) {
        return arg2;
    }

}
