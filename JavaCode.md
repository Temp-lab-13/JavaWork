# Java

Для запуска выполнения файла с консоли, необходимо перейти в папку с запускаемым файлом, указать ключевое слово `java`, и после него указать полное название файла, вместе с его расширением:

```java
java название_файла.java
```
Комментарии указываются:
* Однострочние - //
* Многострочные - /** (Начало->Конец) */ 

## Снипиты
> __Снипиты__ - это ключевые слова - подсказки среды разработки, позволяюбщие быстро создать контсрукции кода, с помощью этой самой среды, без необходимости полность их прописывать.

`main` - создание точки входа.

`class` - создание класса

`sysout` - создание кода для вывода текста.
### Вывод данных.
```java
System.out.println("Текст");
// Выводит в консоль указанное в аргументах значение. 
System.out.println(Arrays.toString(массив));
// Выводит в консоль массив.
```
### Ввод данных.
Ввод данных требует приготовлений.
 * глобальный импорт `java.util.Scanner;`
 * Создание экземляра класса `Scanner`
 * Вызов экземпляра для инициализации ввода и указания соответсвубщего модификатора.
 * Завершение.

__Важно!__, для ввода разных типов данных, нужен соответсвующий модификатор, который классифицирует каким типом данных будут введённые с консоли значения: 

* `nextLine()` - срочный тип данных.
* `nextInt()` - целочисленный тип данных.
* `nextDouble()` - вещественный тип данных.

И так далее.

```java
import java.util.Scanner;
//импорт записывается в не класса, в самом верху.
Scanner iScanner = new Scanner(System.in);
String text = iScanner.nextLine();
// Последняя строка отвечает за непосрественный ввод
// с консоли, в данном случаи - строки. 
// И присвоение введёного значения переменной,
// в данном случаи имеющей название `taxt`.
// Разумеется, ввод не обязательно сохранять в перменную,
// если он будет использоваться сразу же.
iScanner.close();
// Завершение операции.
```

## Массивы
Инициализация массива.

Необьходимо указать тип данных(к примеру: `int`), а после название массива. После чего присвоить ему дилну в конструкции `new тип_данных[длина]` или сразу указать значения в контрукции `new тип_данных[] {певое_значение, второе_значение, и_т.д}`
```java
int[] arr1 = new int[10];
// Создаём пустой массив и задём ему длину 10.
int[] arr2 = new int[] {1, 2, 3, 4}; //1 вариант.
int[] arr3 = {1, 2, 3, 4}; // 2 Вариант.
// Создаём массив и вкладываем в него значения. 
// Длина будет соответсвовать колличеству указанных значений.
int[] arry[] = new int[3][5];
// Инициализация двумерного массива.
int[][] arri = new int[3][5];
//Инициализация массива массивов.
```

Обращение к элементу массива.
```java
int[] arr = new int[] {1, 2, 4};
arr[1] // 2 
arr[1] = 13 // 2-ку в массиве заменит число 13
```

## Коллиекции

### ArrayList
Похож на массив.

Создание листа.
```java
// Сырой лист без обозначения типа.
// В него можно положить любой ти данных (одинаковый).
// Но, из-за его преобразования в Object, раотает медленей.
ArrayList list = new ArrayList();
// Тиизированный лист. Предпочтительней.
ArrayList<Integer> list = new ArrayList<Integer>();
ArrayList<Integer> list2 = new ArrayList<>();
// Создание листа с определённым размером(его можно менять)
ArrayList<Integer> list3 = new ArrayList<>(10); 
// Создание листа с присвоением значений другого листа.
ArrayList<Integer> list4 = new ArrayList<>(list3);
```

Добавление эелмена.
```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(23);
```
Вывод.
```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(23);
list.add(1);
//Вывод каждого элемента через форич.
for (Object o : list) {
    System.out.println(o);
}
```

Другие методы.
```java
add(args)
// добавляет элемент в список ( в т.ч. на нужную позицию)
get(pos)
// возвращает элемент из списка по указанной позиции
indexOf(item) 
// первое вхождение или -1
lastIndexOf(item) 
// последнее вхождение или -1
remove(pos) 
// удаление элемента на указанной позиции и его возвращение
set(int pos, T item) 
// помещает значение item элементу, который находится
на позиции pos
void sort(Comparator) 
// сортирует набор данных по правилу
subList(int start, int end) 
// получение набора данных от позиции start до end
clear() 
// очистка списка
toString() 
// «конвертация» списка в строку
Arrays.asList 
// преобразует массив в список
containsAll(col) 
// проверяет включение всех элементов из col
removeAll(col) 
// удаляет элементы, имеющиеся в col
retainAll(col) 
// оставляет элементы, имеющиеся в col
toArray() 
// конвертация списка в массив Object’ов
toArray(type array) 
// конвертация списка в массив type
List.copyOf(col) 
// возвращает копию списка на основе имеющегося
List.of(item1, item2,...) 
// возвращает неизменяемый список
```
Итератор
`Iterator<E>` - `Е` - тип данных.

Методы: `hasNext()`, `next()`, `remove()`.
```java
Iterator<Integer> col = list.iterator();
while (col.hasNext()) {
System.out.println(col.next());
}
```
`ListIterator<E> URL`

Методы: `hasPrevious()`, `E previous()`, `nextIndex()`, `previousIndex()`, `set(E e)`, `add(E e)`

## API

> #### _Application programming interface_ (API) - это контракт, который предоставляет пограмма. "Ко мне можно обращаться так и так, я обязуюсь делать это."

### Строки
Класс `StringBuilder` значительно ускоряет обработку больших строк.
```java
// Пример создания строки из миллиона `+`.
// Скорость выполнения значительно выше чем, 
// если бы мы использовали обычный 'String'.
StringBuilder text = new StringBuilder();
for (int i = 0; i < 1_000_000; i++) {
    text.append("+");
}
```
Методы `StringBuilder`
```java
StringBuilder text = new StringBuilder();
text.append("текст"); //Добавление в строку
```
Методы `String`
```java
String text = "текст текст";
text.concat() 
// Объединение строк
text.valueOf() 
// Преобразует Object в строковое представление (завязан на toString())
text.join() 
// Объединяет набор строк в одну с учетом разделителя
text.charAt() 
// Получение символа по индексу
text.indexOf() 
// Первый индекс вхождения подстроки
text.lastIndexOf() 
// Последний индекс вхождения подстроки
text.startsWith()/endsWith() 
// Определяет, начинается/заканчивается ли строка с подстроки
text.replace() 
// Замена одной подстроки на другую
text.trim()
// Удаляет начальные и конечные пробелы
text.substring() 
// Возвращает подстроку, см.аргументы
text.toLowerCase()/toUpperCase() 
// Возвращает новую строку в нижнем/верхнем регистре
text.сompareTo() 
// Сравнивает две строки
text.equals() 
// Сравнивает строки с учетом регистра
text.equalsIgnoreCase() 
//Сравнивает строки без учета регистра
text.regionMatches() 
//Сравнивает подстроки в строках
```

### Работа с файлами

```java
// Подключение файла, и содание переменной с данными их него, для работы с ним в коде.
File f1 = new File("file.txt");
File f2 = new File("/Users/sk/vscode/java_projects/file.txt");

```
Сохранение пути к файлу в отдельную переменную.
```java
// 1-й вариант. Относительный путь.
//(относительно нашего исполняемого файла, к пирмеру.)
String pathProject = System.getProperty ("user.dir" );
// 2-й вариант. Абсолютный путь. 
//Т.е. это полный путь от корня диска через все дирректории к загружаемому файлу.
String pathFile = pathProject .concat("/file.txt" );
// Загружаем в перменную f3 файл,
// путь к которому записан в переменной 'pathFile'
File f3 = new File(pathFile);
// Метод 'getAbsolutePath()' позволяет получить
// абсолютный путь переменной связанной с файлом..
System.out.println(f3.getAbsolutePath());
//Вывод: /Users/sk/vscode/java_projects/file.txt
```
Запись в файл.
```java
// Создание переменной для работы с файлом по пути 
// указанном в аругментах.
FileWriter wr = new FileWriter(filePath);
// Указывается что должно быть записано в файл.
wr.write(text);
// непосредственно запись ранее указанного в методах `wr`
wr.flush();
// закрытие подключение к файлу.
wr.close();
```
Методы работы с файлами или папками.
```java
isHidden() 
// Возвращает истину, если каталог или файл является скрытым
length() 
// Возвращает размер файла в байтах
lastModified() 
// Возвращает время последнего изменения файла или каталога
list()
// Возвращает массив файлов и подкаталогов, которые находятся в каталоге
listFiles()
// Возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
mkdir()
// Создает новый каталог
renameTo(File dest)
// Переименовывает файл или каталог
length()
// Возвращает размер файла в байтах
lastModified()
// Возвращает время последнего изменения файла или каталога
list()
// Возвращает массив файлов и подкаталогов, которые находятся в каталоге
listFiles() 
// Возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге
mkdir()
// Создает новый каталог
renameTo(File dest)
// Спереименовывает файл или каталог
```
Бинарные файла.

```java

```
### Обработка ошибок.
Обработчик `try-catch` Позволяет поймать ошибку, обработать её (вывести предупреждение, лог или даже тип), и пробложить выполнение программы, не останавляивая её. (программа проболжит работать даже с ошибкой, а не упадёт.)
```java
try {
//Код, в котором может появиться ошибка
} catch (Exception e) {
//Обработка, если ошибка случилась, то выполнится это блок.
}
finally {
//Код, который выполнится в любом случае после отработки
// блокак try, или даже если если сработает catch.
}
```

Проброска возникшего исключения/ошибки, на уровень выше способом `throws`.

```java
public static void main(String[] args) {
        String filePath = "SeminarTwo/text.txt";
        String text = "TEST";
        //Вызов метода. Именно сюда будет проброшено исключение, где его нужно будет обработать, иначе, программа упадёт.
        writeFile(text, filePath);
        
    }

// Работа с файлами требует обязательно обработчика 
// исключений, иначе, программа не запустится.
// Однако, `throws Exception` позволяет выкинуть возникшую ошибку из метода на уровень выше. В данном случаи в корневой метод `main`, где и вызывается данный метод `writeFile`, для того что бы возмоную ошибку можно было боработать там.
static void writeFile(String text, String filePath) throws Exception {
        FileWriter writer = new FileWriter(filePath);
        writer.write(text);
        writer.flush();
        writer.close();
    }
```


Логирование

Для использования необходимо создать объект, к которому мы приаязем логируемый класс или метода (это можно указать в аргументах`getLogger()`):
`Logger loge = Logger.getLogger()`

После, необходимо создать объект-вывод, который будет опреелять куда будут выводиться логи, к примеру в консоль:

`ConsoleHandler info = new ConsoleHandler();`

`loge.addHandler(info);` 

(для вывода же в файла - FileHandler, в аргументах указывается файла для записи.)
Далее нобходимо объекту выводу казать формат:

`SimpleFormatter sFormat = new SimpleFormatter();`

`info.setFormatter(sFormat);`

(Форматы бывают разных видов, к пирмеру: XMLFormatter, SimpleFormatter)

И лишь после этого всего выбирается тип лога. (Основные типы логов:INFO, DEBUG, ERROR, WARNING и др.) Которые указываются либо аргументом, либо методом в соответсвии со своим названием:

`loge.log(Level.WARNING, "Тестовое логирование" );`

`loge.info("Тестовое логирование" )`

Сдесь же указывается и необходимый текст - пояснение.

```java
// Пример в коде. с форматом вывода `SimpleFormatter`.
import java.util.logging.*;
public class Ex0043 {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger(Ex0043.class.getName());
        logger.setLevel(Level.INFO);
        ConsoleHandler ch = new ConsoleHandler ();
        logger.addHandler (ch);
        SimpleFormatter sFormat = new SimpleFormatter ();
        ch.setFormatter (sFormat);
        logger.log(Level.WARNING, "Тестовое логирование" );
        logger.info("Тестовое логирование" );
    }
}
```